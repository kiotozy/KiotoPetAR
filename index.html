<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Kioto AR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    
    <!-- A-Frame & extras -->
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-gesture-detector@3.3.0/dist/aframe-gesture-detector.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-ar@1.8.0/dist/aframe-ar.min.js"></script>

    <style>
      .a-enter-vr-button {
        display: none !important;
      }

      .action-buttons {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: row;
        gap: 10px;
        z-index: 9999;
      }

      .action-buttons button {
        padding: 10px 20px;
        font-size: 14px;
        background-color: #1976d2;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
      }

      .action-buttons button:hover {
        background-color: #125ea5;
      }
    </style>

    <script>
      // Redimensionamento por pinça
      AFRAME.registerComponent('scale-on-pinch', {
        schema: { default: 1 },

        init: function () {
          const el = this.el;
          this.initialScale = el.object3D.scale.clone();

          el.addEventListener('pinchstart', (e) => {
            this.startScale = el.object3D.scale.clone();
          });

          el.addEventListener('pinchmove', (e) => {
            const scaleFactor = e.detail.scale;
            el.object3D.scale.set(
              this.startScale.x * scaleFactor,
              this.startScale.y * scaleFactor,
              this.startScale.z * scaleFactor
            );
          });
        }
      });

      // Componente de animação por comando
      AFRAME.registerComponent('play-on-command', {
        init: function () {
          const model = this.el;
          model.addEventListener('model-loaded', () => {
            model.setAttribute('animation-mixer', { clip: 'Idle', loop: 'repeat' });
          });

          window.addEventListener('command', (event) => {
            const action = event.detail.action;
            model.setAttribute('animation-mixer', { clip: action, loop: 'repeat' });
          });
        }
      });

      // Movimento por arrastar
      AFRAME.registerComponent('drag-rotate-position', {
        schema: {
          enabled: { default: true },
        },
        init: function () {
          this.isDragging = false;
          this.previousPosition = null;
        },
        play: function () {
          this.addEventListeners();
        },
        pause: function () {
          this.removeEventListeners();
        },
        addEventListeners: function () {
          this.el.sceneEl.canvas.addEventListener('touchstart', this.onTouchStart.bind(this), false);
          this.el.sceneEl.canvas.addEventListener('touchmove', this.onTouchMove.bind(this), false);
          this.el.sceneEl.canvas.addEventListener('touchend', this.onTouchEnd.bind(this), false);
        },
        removeEventListeners: function () {
          this.el.sceneEl.canvas.removeEventListener('touchstart', this.onTouchStart.bind(this));
          this.el.sceneEl.canvas.removeEventListener('touchmove', this.onTouchMove.bind(this));
          this.el.sceneEl.canvas.removeEventListener('touchend', this.onTouchEnd.bind(this));
        },
        onTouchStart: function (event) {
          if (event.touches.length === 1) {
            this.isDragging = true;
            this.previousPosition = event.touches[0];
          }
        },
        onTouchMove: function (event) {
          if (!this.isDragging || event.touches.length !== 1) return;

          const deltaX = event.touches[0].clientX - this.previousPosition.clientX;
          const deltaZ = event.touches[0].clientY - this.previousPosition.clientY;

          const position = this.el.object3D.position;
          position.x += deltaX * 0.005;
          position.z += deltaZ * 0.005;

          this.previousPosition = event.touches[0];
        },
        onTouchEnd: function () {
          this.isDragging = false;
        }
      });

      // Envio de comando de animação
      function sendCommand(action) {
        const event = new CustomEvent('command', {
          detail: { action: action }
        });
        window.dispatchEvent(event);
      }
    </script>
  </head>

  <body style="margin: 0; overflow: hidden;">
    <div class="action-buttons">
      <button onclick="sendCommand('Capoeira')">Lutar</button>
      <button onclick="sendCommand('Chute')">Chutar</button>
    </div>

    <a-scene
      id="scene"
      embedded
      arjs="sourceType: webcam;"
      renderer="antialias: true"
      xr-mode-ui="enabled: false"
      vr-mode-ui="enabled: false"
      gesture-detector
    >
      <a-assets>
        <a-asset-item id="model" src="kioto.glb"></a-asset-item>
      </a-assets>

      <a-entity
        id="kioto"
        gltf-model="#model"
        position="0 0 0"
        scale="0.3 0.3 0.3"
        gesture-detector
        play-on-command
        scale-on-pinch
        drag-rotate-position
      ></a-entity>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
    </a-scene>
  </body>
</html>
